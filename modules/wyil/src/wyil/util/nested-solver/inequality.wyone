include "logic.wyone"
include "numerics.wyone"

// ====================================================================
// LessThan
// ====================================================================

term LessThan[AExpr,AExpr] // syntactic sugar

reduce LessThan[AExpr x, AExpr y]:
    => let negx = Mul[-1.0,{|x|}]
       in ZeroLessThan (Sum[0.0,{|y,negx|}])

// ====================================================================
// Inequality
// ====================================================================

term ZeroLessThan(AExpr) // 0 < e

reduce ZeroLessThan(Num(real x)):
    => True, if 0.0 < x
    => False

reduce Not(ZeroLessThan(AExpr x)):
    => let negx = Mul[-1.0,{|x|}]
       in Or{Equals{|x,Num(0.0)|},ZeroLessThan(negx)}

// eliminate variable from *linear* inequality
// NOTE: must be inference rule to ensure Sums are maximally reduced
// NOTE: requirement x2 < 0.0 && y2 > 0.0 ensures we are eliminating variables
infer And{ZeroLessThan(Sum[real x1, {|Mul[real x2, {|AExpr v1|}], Mul... xs|}] s1) ieq1, 
          ZeroLessThan(Sum[real y1, {|Mul[real y2, {|AExpr v2|}], Mul... ys|}] s2) ieq2, 
	  Atom... rest}:
     => let ieq3 = ZeroLessThan(Sum[0.0,{|s1,s2|}])
        in And ({ieq1,ieq2,ieq3} ++ rest), if v1 == v2 && x2 < 0.0 && y2 > 0.0

// eliminate variable from *linear* equation
// NOTE: must be inference rule to ensure Sums are maximally reduced
infer And{Equation(Sum[real x1, {|Mul[real x2, {|AExpr v1|}], Mul... xs|}]) eq1, 
      ZeroLessThan(Sum[real y1, {|Mul[real y2, {|AExpr v2, AExpr... vs|}], Mul... ys|}]) eq2, 
	  Atom... rest}:
     => let eq3 = eq2[v1 \ Mul[-1.0 / x2,{|Sum[x1,xs]|}]]
        in And ({eq1,eq2,eq3} ++ rest), if v1 == v2

// ====================================================================
// Expressions & Values
// ====================================================================

class Atom as ZeroLessThan | ...
