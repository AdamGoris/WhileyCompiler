include "logic.wyone"
include "lists.wyone"
include "sets.wyone"

term QVar(string) // quantified variable

// ====================================================================
// ForAll
// ====================================================================

term ForAll[QVar, Expr, BExpr]

reduce Not(ForAll[QVar qv, Expr src, BExpr be]):
       => Exists[qv, src, Not(be)]

reduce ForAll[QVar qv, SetVal[Value... src], BExpr be]:
       => And { be[qv \ s] | s in src }

reduce ForAll[QVar qv, ListVal[Value... src], BExpr be]:
       => And { be[qv \ s] | s in src }

reduce And{ForAll[QVar qv, Var v1, BExpr qe] b1, 
           Equals{|Var v2, Set[Expr... es]|} b2, 
	   BExpr... bs}:
       => let cs = { qe[qv \ e] | e in es }
          in And (b2 ++ bs ++ cs), if v1 == v2

reduce And{ForAll[QVar qv, Var v1, BExpr qe] b1, 
           Equals{|Var v2, List[Expr... es]|} b2, 
	   BExpr... bs}:
       => let cs = { qe[qv \ e] | e in es }
          in And (b2 ++ bs ++ cs), if v1 == v2

infer And{ForAll[QVar qv, Var v1, BExpr qe] b1, 
           Equals{|Var v2, IndexOf[Var v3, AExpr v4]|} b2, 
	   BExpr... bs}:
       => let b3 = qe[qv \ v2]
          in And ({b1,b2,b3} ++ bs), if v1 == v3

// ====================================================================
// Exists
// ====================================================================

term Exists[QVar, Expr, BExpr]

reduce Not(Exists[QVar qv, Expr src, BExpr be]):
       => ForAll[qv, src, Not(be)]

reduce Exists[QVar qv, SetVal[Value... src], BExpr be]:
       => Or { be[qv \ s] | s in src }

reduce Exists[QVar qv, ListVal[Value... src], BExpr be]:
       => Or { be[qv \ s] | s in src }

// ====================================================================
// Expressions & Values
// ====================================================================

class BExpr as ForAll | Exists | ...





