include "logic.wyone"
include "numerics.wyone"
include "collections.wyone"

// ====================================================================
// Set Expressions
// ====================================================================

term Set{Expr...}

// ====================================================================
// LengthOf
// ====================================================================

reduce LengthOf(Set{Value... xs}):
    => Num((real) |xs|)

reduce And{Equals[Num(int x), LengthOf(Expr v)], BExpr... rest}:
    => And (rest ++ Equals[v,Set{}]), if x == 0

reduce And{Equals[LengthOf(Expr v), Num(int x)], BExpr... rest}:
    => And (rest ++ Equals[v,Set{}]), if x == 0

// ====================================================================
// ElementOf
// ====================================================================

reduce ElementOf[Expr e1, Set{Expr... es}]:
    => True, if e1 in es
    => False, if |es| == 0
    => Or { Equals[e1,e2] | e2 in es }

// ====================================================================
// Union
// ====================================================================

term Union{SExpr...}

reduce Union{Set{Expr... xs},Set{Expr... ys}, Expr... rest}:
    => Union (Set(xs++ys) ++ rest)

reduce Union{Expr e}:
    => e

reduce ElementOf[Expr e1, Union{SExpr... xs}]:
    => let ys = { ElementOf[e1,x] | x in xs }
       in Or(ys)

// ====================================================================
// Intersect
// ====================================================================

term Intersect{SExpr...}

reduce Intersect{Set{Expr... xs},Set{Expr... ys}, Expr... rest}:
     => let zs = { x | x in xs, true && x in ys }
        in Set(zs)

reduce Intersect{Expr e}:
    => e

reduce ElementOf[Expr e1, Intersect{SExpr... xs}]:
    => let ys = { ElementOf[e1,x] | x in xs }
       in And(ys)
// ====================================================================
// Difference
// ====================================================================

term Difference[SExpr,SExpr]

reduce Difference[Set{Expr... xs},Set{Expr... ys}]:
     => let zs = { x | x in xs, !(x in ys) }
        in Set(zs)

// ====================================================================
// Expressions & Values
// ====================================================================

define Value as Set{Value...} | ...

define SExpr as VExpr | Set | Union | ...

define BExpr as ElementOf | ...

define Expr as SExpr | ...
