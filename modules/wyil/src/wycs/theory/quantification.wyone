include "logic.wyone"
include "lists.wyone"
include "sets.wyone"

term QVar(string) // quantified variable

// ====================================================================
// ForAll
// ====================================================================

term ForAll[QVar, Expr, BExpr]

reduce Not(ForAll[QVar qv, Expr src, BExpr be]):
       => Exists[qv, src, Not(be)]

reduce ForAll[QVar qv, Set{Expr... src}, BExpr be]:
       => And { be[qv \ s] | s in src }

reduce ForAll[QVar qv, List[Expr... src], BExpr be]:
       => And { be[qv \ s] | s in src }

infer And{ForAll[QVar qv, VExpr v1, BExpr qe] b1, 
           Equals{|Var v2, IndexOf[Var v3, AExpr v4]|} b2, 
	   BExpr... bs}:
       => let b3 = qe[qv \ v2]
          in And ({b1,b2,b3} ++ bs), if v1 == v3

infer And{ForAll[QVar qv, VExpr v1, BExpr qe] b1, 
           ElementOf[Expr v2, Expr v3] b2, 
	   BExpr... bs}:
       => let b3 = qe[qv \ v2]
          in And ({b1,b2,b3} ++ bs), if v1 == v3

// ====================================================================
// Exists
// ====================================================================

term Exists[QVar, Expr, BExpr]

reduce Not(Exists[QVar qv, Expr src, BExpr be]):
       => ForAll[qv, src, Not(be)]

reduce Exists[QVar qv, Set{Value... src}, BExpr be]:
       => Or { be[qv \ s] | s in src }

reduce Exists[QVar qv, List[Value... src], BExpr be]:
       => Or { be[qv \ s] | s in src }

reduce Exists[QVar(string s) qv, Expr e, BExpr be]:
       => let v = Var(s)
          in And { ElementOf[v,e], be[qv \ v] }

// ====================================================================
// Expressions & Values
// ====================================================================

define BExpr as ForAll | Exists | ...

define VExpr as QVar | ...




