include "logic.wyone"
include "numerics.wyone"

// ====================================================================
// List Expressions
// ====================================================================

term List[Expr...]

// ====================================================================
// List Length
// ====================================================================

reduce LengthOf(List[Expr... ls]):
    => Num((real) |ls|)

// ====================================================================
// List Index
// ====================================================================

term IndexOf[LExpr,AExpr] // source, index

reduce IndexOf[List[Expr... ls], Num(real rdx)]:
    => let idx = num rdx
       in ls[idx], if (den rdx == 1) && idx >= 0 && idx < |ls|

// ====================================================================
// List ELement Of
// ====================================================================

term ListElementOf[Expr,Expr,LExpr] // key,value,index

reduce ListElementOf[Num(real rdx), Expr val, List[Expr... ls]]:
    => let idx = num rdx
       in Equals{|val,ls[idx]|}, if (den rdx == 1) && idx >= 0 && idx < |ls|

reduce ListElementOf[Expr idx, Expr val, List[Expr... es] l]:
    => let eqs = { And{Equals[idx,Num((real)i)],Equals[val,es[i]]} | i in 0 .. |es| }
       in Or (eqs)

// ====================================================================
// List Append
// ====================================================================

term Append[LExpr,LExpr]

reduce Append[List[Expr... xs], List[Expr... ys]]:
    => List(xs ++ ys)

reduce LengthOf(Append[LExpr lhs, LExpr rhs]):
    => Sum[0.0,{|LengthOf(lhs),LengthOf(rhs)|}]

// reduce ElementOf[Expr e1, Append[LExpr lhs, LExpr rhs]]:
//     => Or { ElementOf[e1,lhs], ElementOf[e1,rhs] }

// ====================================================================
// List SubList
// ====================================================================

term SubList[LExpr,AExpr,AExpr]

// reduce SubList[List[Expr... xs], Num(real start), Num(real end)]:
//     => xs[start..end]

// ====================================================================
// List Update
// ====================================================================

term ListUpdate[LExpr,AExpr,Expr] // src index value

reduce ListUpdate[List[Expr... ls],Num(real rdx),Expr e]:
    => let idx = num rdx
       in List(ls[idx = e]), if (den rdx == 1) && idx >= 0 && idx < |ls|

reduce LengthOf(ListUpdate[Expr src, AExpr idx, Expr val]):
    => LengthOf(src)

// reduce ElementOf[Expr elem, ListUpdate[Expr src, AExpr idx, Expr val]]:
//     => Or { Equals[elem,val], Equals[elem,IndexOf[src,??]] }

// ====================================================================
// Expressions & Values
// ====================================================================

define Value as List[Value...] | ...

define BExpr as ListElementOf | ...

define LExpr as VExpr | List | Append | SubList | ListUpdate | ...

define VExpr as IndexOf | ...

define Expr as LExpr | ...
