include "logic.wyone"
include "numerics.wyone"
include "quantification.wyone"

// ====================================================================
// List Expressions
// ====================================================================

term List[Expr...]

// ====================================================================
// List Length
// ====================================================================

reduce LengthOf(List[Expr... ls]):
    => Num((real) |ls|)

// ====================================================================
// List Index
// ====================================================================

term IndexOf[LExpr,AExpr] // source, index

reduce IndexOf[List[Expr... ls], Num(real rdx)]:
    => let idx = num rdx
       in ls[idx], if (den rdx == 1) && idx >= 0 && idx < |ls|

// ====================================================================
// List ELement Of
// ====================================================================

term ListElementOf[AExpr,Expr,LExpr] // index,value,src

reduce ListElementOf[Num(real rdx), Expr val, List[Expr... ls]]:
    => let idx = num rdx
       in Equals[val,ls[idx]], if (den rdx == 1) && idx >= 0 && idx < |ls|

reduce ListElementOf[AExpr idx, Expr val, List[Expr... es] l]:
    => False, if |es| == 0
    => let eqs = { And{Equals[idx,Num((real)i)],Equals[val,es[i]]} | i in 0 .. |es| }
       in Or (eqs)

reduce ListElementOf[AExpr i1, Expr v1, ListUpdate[Expr src, AExpr i2, Expr v2]]:
    => let lhs = And{ ListElementOf[i1,v1,src], Not(Equals[i1,i2]) },
           rhs = And{ Equals[v1,v2], Equals[i1,i2] }
       in Or { lhs, rhs }

reduce ListElementOf[AExpr i1, Expr v1, Append[LExpr left, LExpr right]]:
       => let lhs = And { ListElementOf[i1,v1,left], LessThan[i1,LengthOf(left)] },
              rhs = And { ListElementOf[Sum[0.0,{|i1,LengthOf(left)|}],v1,right], LessThanEq[LengthOf(left),i1] }
          in Or { lhs,rhs }

// ====================================================================
// List Append
// ====================================================================

term Append[LExpr,LExpr]

reduce Append[List[Expr... xs], List[Expr... ys]]:
    => List(xs ++ ys)

reduce LengthOf(Append[LExpr lhs, LExpr rhs]):
    => Sum[0.0,{|LengthOf(lhs),LengthOf(rhs)|}]

// ====================================================================
// List SubList
// ====================================================================

term SubList[LExpr,AExpr,AExpr]

// reduce SubList[List[Expr... xs], Num(real start), Num(real end)]:
//     => xs[start..end]

// ====================================================================
// List Update
// ====================================================================

term ListUpdate[LExpr,AExpr,Expr] // src index value

reduce ListUpdate[List[Expr... ls],Num(real rdx),Expr e]:
    => let idx = num rdx
       in List(ls[idx = e]), if (den rdx == 1) && idx >= 0 && idx < |ls|

reduce LengthOf(ListUpdate[Expr src, AExpr idx, Expr val]):
    => LengthOf(src)

// ====================================================================
// For All
// ====================================================================

reduce ForAll[QVar qv, List[Expr... src], BExpr be]:
       => And { be[qv \ s] | s in src }, if |src| > 0
       => True

reduce ForAll[QVar qv, Append[LExpr lhs,LExpr rhs], BExpr be]:
       => And{ ForAll[qv,lhs,be], ForAll[qv,rhs,be] }

infer And{ForAll[QVar qv, VExpr v1, BExpr qe] b1, 
           ListElementOf[Expr idx, Expr val, LExpr v2] b2, 
	   BExpr... bs}:
       => let qs = qe[qv \ val]
          in And ({b1,b2} ++ qs ++ bs), if v1 == v2

// ====================================================================
// Exists
// ====================================================================

reduce Exists[QVar qv, List[Value... src], BExpr be]:
       => Or { be[qv \ s] | s in src }, if |src| > 0
       => False

// ====================================================================
// Expressions & Values
// ====================================================================

define Value as List[Value...] | ...

define BExpr as ListElementOf | ...

define LExpr as VExpr | List | Append | SubList | ListUpdate | ...

define VExpr as IndexOf | ...

define Expr as LExpr | ...
