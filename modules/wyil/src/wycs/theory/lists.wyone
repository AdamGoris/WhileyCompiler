include "logic.wyone"
include "numerics.wyone"
include "sets.wyone"

// ====================================================================
// List Index
// ====================================================================

term IndexOf[SExpr,AExpr] // source, index
term Map[Expr,Expr]

reduce IndexOf[Set{Map[Expr key,Expr value], Expr... rest}, Expr idx]:
    => value, if key == idx

// ====================================================================
// List Append
// ====================================================================

term Append[SExpr,SExpr]

// reduce Append[List[Expr... xs], List[Expr... ys]]:
//     => List(xs ++ ys)

// reduce LengthOf(Append[LExpr lhs, LExpr rhs]):
//     => Sum[0.0,{|LengthOf(lhs),LengthOf(rhs)|}]

// reduce ElementOf[Expr e1, Append[LExpr lhs, LExpr rhs]]:
//     => Or { ElementOf[e1,lhs], ElementOf[e1,rhs] }

// ====================================================================
// List SubList
// ====================================================================

term SubList[LExpr,AExpr,AExpr]

// reduce SubList[List[Expr... xs], Num(real start), Num(real end)]:
//     => xs[start..end]

// ====================================================================
// List Update
// ====================================================================

term Update[SExpr,AExpr,Expr] // src index value

// reduce Update[List[Expr... ls],Num(real rdx),Expr e]:
//     => let idx = num rdx
//        in List(ls[idx = e]), if (den rdx == 1) && idx >= 0 && idx < |ls|

reduce LengthOf(Update[Expr src, AExpr idx, Expr val]):
    => LengthOf(src) // broken for maps

// reduce ElementOf[Expr elem, Update[Expr src, AExpr idx, Expr val]]:
//     => Or { Equals[elem,val], Equals[elem,IndexOf[src,??]] }

// ====================================================================
// Expressions & Values
// ====================================================================

define VExpr as IndexOf | ...

define SExpr as Update | ...

define Expr as Append | SubList | ...


