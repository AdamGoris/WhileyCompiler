include "logic.wyone"
include "numerics.wyone"

// ====================================================================
// List Expressions
// ====================================================================

term List[Expr...]

// ====================================================================
// List Length
// ====================================================================

reduce LengthOf(List[Expr... ls]):
    => Num((real) |ls|)

// ====================================================================
// List Index
// ====================================================================

term IndexOf[LExpr,AExpr] // source, index

reduce IndexOf[List[Expr... ls], Num(real rdx)]:
    => let idx = num rdx
       in ls[idx], if (den rdx == 1) && idx >= 0 && idx < |ls|

// ====================================================================
// List ELement Of
// ====================================================================

reduce ElementOf[Expr e1, List[Expr... es] l]:
    => True, if e1 is Value && e1 in es
    => False, if |es| == 0 || e1 is Value && l is List[Value...]
    => Or { Equals{|e1,e2|} | e2 in es }

// ====================================================================
// List Append
// ====================================================================

term Append[LExpr,LExpr]

reduce Append[List[Expr... xs], List[Expr... ys]]:
    => List(xs ++ ys)

reduce LengthOf(Append[LExpr lhs, LExpr rhs]):
    => Sum[0.0,{|LengthOf(lhs),LengthOf(rhs)|}]

reduce ElementOf[Expr e1, Append[LExpr lhs, LExpr rhs]]:
    => Or { ElementOf[e1,lhs], ElementOf[e1,rhs] }

// ====================================================================
// List Update
// ====================================================================

term ListUpdate[LExpr,AExpr,Expr] // src index value

reduce ListUpdate[List[Expr... ls],Num(real rdx),Expr e]:
    => let idx = num rdx
       in List(ls[idx = e]), if (den rdx == 1) && idx >= 0 && idx < |ls|

reduce LengthOf(ListUpdate[Expr src, AExpr idx, Expr val]):
    => LengthOf(src)

// reduce ElementOf[Expr elem, ListUpdate[Expr src, AExpr idx, Expr val]]:
//     => Or { Equals{|elem,val|}, Equals{|elem,IndexOf[src,??]|} }

// ====================================================================
// Expressions & Values
// ====================================================================

define Value as List[Value...] | ...

define LExpr as VExpr | List | ListUpdate | ...

define VExpr as IndexOf | ...

define Expr as LExpr | ...
