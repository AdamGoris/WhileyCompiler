// ==================================================
// Theory of Values
// ==================================================

term True
term False
class Bool as True | False

// ==================================================
// Theory of Logical Connectives
// ==================================================

// --- Logical And ---
term And{Term...}

rewrite And{Bool b, Term... xs}:
    => False(), if b is False
    => And(xs)

rewrite And(Term t):
    => t

rewrite And():
    => True()

// --- Logical Or ---
term Or{Term...}

rewrite Or{Bool b, Term... xs}:
    => True(), if b is True
    => Or(xs)

rewrite Or(Term t):
    => t

rewrite Or():
    => False()

// --- Logical Not ---
term Not(Term)

rewrite Not(Bool b):
    => True(), if b is False
    => False()

rewrite Not(Not(* x)):
    => x

// rewrite Not(And(Term... xs)):

// rewrite Not(Or(Term... xs)):

// ==================================================
// Theory of Equality
// ==================================================

term Num
term Eq{Expr,Expr}
term Ne{Expr,Expr}

//rewrite Eq(Expr x, Expr y):
//    => True(), if x == y

//rewrite Ne(Expr x, Expr y):
//    => False(), if x == y

rewrite Not(Eq{Expr x,Expr y}):
    => Ne(x,y)

rewrite Not(Ne{Expr x,Expr y}):
    => Eq(x,y)

// ==================================================
// Theory of Inequality
// ==================================================

term Le(Expr,Expr)
term Lt(Expr,Expr)

//rewrite Lt(Expr x, Expr y):
//    => False(), if x == y

//rewrite And{Le(Expr x, Expr y), Le(Expr u, Expr v),Term... xs}:
//    => And{Eq(Expr x, Expr y),xs}, if x == y && y == v

//rewrite And{Le(Expr x, Expr y), Le(Expr u, Expr v),Term... xs}:
//    => And{Le(Expr x, Expr v),xs}, if y == u

//rewrite And{Lt(Expr x, Expr y), Le(Expr u, Expr v),Term... xs}:
//    => And{Lt(Expr x, Expr v),xs}, if y == u

//rewrite And{Le(Expr x, Expr y), Lt(Expr u, Expr v),Term... xs}:
//    => And{Lt(Expr x, Expr v),xs}, if y == u

//rewrite And{Lt(Expr x, Expr y), Lt(Expr u, Expr v),Term... xs}:
//    => And{Lt(Expr x, Expr v),xs}, if y == u

rewrite Not(Le(Expr x,Expr y)):
    => Lt(y,x)

rewrite Not(Lt(Expr x,Expr y)):
    => Le(y,x)

// ==================================================
// Combined Theories
// ==================================================

class Term as Bool | And | Or | Not | Eq | Ne | Le | Lt
class Expr as Num
