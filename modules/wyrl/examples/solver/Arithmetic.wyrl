// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//    * Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//    * Neither the name of the <organization> nor the
//      names of its contributors may be used to endorse or promote products
//      derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

include "Core.wyrl"

// ====================================================================
// Multplication
// ====================================================================

// A multiplication term consists of a constant, and zero or more 
// variable multipliers.  For example, 2*x*y.
term Mul[real,{|AExpr...|}]

// Zero multiplied by anything gives zero (1); A term with no
// multipliers is just a number (2).
reduce Mul[real n, {|AExpr... rest|}]:
    => Num(n), if n == 0.0 || |rest| == 0

// Simplify terms containing constant multipliers.
reduce Mul[real x, {|Num(real y), AExpr... rest|}]:
    => Mul[x*y,rest]

// Flattern nested multiplication terms.
reduce Mul[real n1, {|Mul[real n2,{|AExpr... xs|}], AExpr... ys|}]:
    => Mul[n1*n2,(xs ++ ys)]

// Distribute multiplication through addition.
reduce Mul[real n1, {|Sum[real n2, {|AExpr... xs|}], AExpr... ys|}]:
    => let ys = {| Mul[n1, (x ++ ys)] | x in xs |}
       in Sum[n1*n2,ys]

// ====================================================================
// Division
// ====================================================================

term Div[AExpr,AExpr]

// TO DO!

// ====================================================================
// Summation
// ====================================================================

// A summation consists of a constant, and zero or more 
// multiplication components.  For example, 2+(1*x)+(1*y) 
// and also 2+(x*y)+z.
term Sum[real,{|AExpr...|}]

// A summation with no components is just a number.
reduce Sum[real n, {||}]:
    => Num(n)

// Normalise so that all variable summation components are multiplications.
reduce Sum[real n, {|AExpr x, AExpr... rest|}]:
    => Sum [n,Mul[1.0,{|x|}] ++ rest], if !(x is Num || x is Sum || x is Mul)

// Simplify summations with constant components.
reduce Sum[real x, {|Num(real y), AExpr... rest|}]:
    => Sum[x+y,rest]

// Simplify summations with related multication components.  
// For example, (2*x*y)+(3*x*y)+(2*x) ==> (5*x*y) + (2*x)
reduce Sum[real n, {|Mul[real x, {|AExpr...|} xs], Mul[real y, {|AExpr...|} ys], AExpr... zs|}]:
    => Sum[n, Mul[x+y, xs] ++ zs], if xs == ys

// Flattern summations.
reduce Sum[real x, {|Sum[real y, {|AExpr... ys|}], AExpr... xs|}]:
    => Sum[x+y, xs ++ ys]

// ====================================================================
// Equations
// ====================================================================
term LT   // LESS THAN
term LE  // LESS THAN OR EQUALS
term EQ   // EQUALS

define EqOp as LT | LE | EQ

// TODO: include type information (int or real) in equations.

// An equation should be viewed as comparing a given expression
// against zero using a given operator (<,<=,==).
term Equation[EqOp,AExpr]

// 0 < 0 is false (1); 0 < -1 is false (1); 0 < 1 is true (2)
reduce Equation[LT op, Num(real v)]:
    => False, if v <= 0.0
    => True

// 0 <= -1 is false (1); 0 <= 0 is true (2); 0 <= 1 is true (2)
reduce Equation[LE op, Num(real v)]:
    => False, if v < 0.0
    => True

// 0 == 1 is false (1); 0 == 0 is true (2)
reduce Equation[EQ op, Num(real v)]:
    => False, if v != 0.0
    => True

// !(0 < e) ==> 0 <= -e
reduce Not(Equation[LT op, AExpr e]):
    => let neg_e = Mul[-1.0,{|e|}]
       in Equation[LE,neg_e]

// !(0 <= e) ==> 0 < -e
reduce Not(Equation[LE op, AExpr e]):
    => let neg_e = Mul[-1.0,{|e|}]
       in Equation[LT,neg_e]

// !(0 == e) ==> 0 < -e || 0 < e
reduce Not(Equation[EQ op, AExpr e]):
    => let neg_e = Mul[-1.0,{|e|}]
       in Or{Equation[LT,e],Equation[LT,neg_e]}

// Examples:
//  1) 0 < x + y && x < 0 ==> ... && 0 < y
//  2) 0 <= x + y && x <= 0 ==> ... && 0 <= y
//  3) 0 == x + y && x <= 0 ==> ... && 0 <= y
//
// FIXME: it would be nice to further simplify this rule by condensing
// both cases into one.  This would improve performance and could easily
// be done using a function.
infer And{Equation[EqOp op1, Sum[real x1, {|Mul[real x2, {|AExpr v1|}], Mul... xs|}] s1] eq1, 
          Equation[EqOp op2, Sum[real y1, {|Mul[real y2, {|AExpr v2|}], Mul... ys|}] s2] eq2, 
	  BExpr... rest}:
     => let s3 = Mul[y2,{|Sum[x1,xs]|}],
            s4 = Mul[-x2,{|Sum[y1,ys]|}],
            eq3 = Equation[op1,Sum[0.0,{|s3,s4|}]]
        in And ({eq1,eq2,eq3} ++ rest), if v1 == v2 && x2 < 0.0 && y2 > 0.0 && (op1 == op2 || op1 == LT || (op1 == LE && op2 != LT))
     => let s3 = Mul[y2,{|Sum[x1,xs]|}],
            s4 = Mul[-x2,{|Sum[y1,ys]|}],
            eq3 = Equation[op2,Sum[0.0,{|s3,s4|}]]
        in And ({eq1,eq2,eq3} ++ rest), if v1 == v2 && x2 < 0.0 && y2 > 0.0 && (op1 == op2 || op2 == LT || (op2 == LE && op1 != LT))

// ====================================================================
// Arithmetic Expressions
// ====================================================================

term Num(real)

define Value as Num | ...

define BExpr as Equation | ...

define AExpr as Num | Sum | Mul | Div | VExpr

