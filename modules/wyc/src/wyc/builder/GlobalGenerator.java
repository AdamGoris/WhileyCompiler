package wyc.builder;

import java.util.*;

import static wyc.lang.WhileyFile.*;
import wyil.lang.*;
import wybs.lang.NameID;
import wybs.lang.Path;
import wybs.util.ResolveError;
import wyc.lang.SyntacticType;
import wyc.lang.TypePattern;
import wyc.lang.WhileyFile;

/**
 * <p>
 * The global generator is responsible for generating wyil bytecode for "global"
 * items. Essentially, this comes down to type constraints and partial
 * constants. For example:
 * </p>
 * 
 * <pre>
 * define nat as int where $ >= 0
 * 
 * int f(nat x):
 *    return x-1
 * </pre>
 * 
 * <p>
 * The global generator is responsible for generating the code for the
 * constraint on <code>nat</code>. Note, local generator are responsible for
 * inlining that constraint into the body of function <code>f</code>.
 * </p>
 * 
 * <p>
 * The code generated by the global generator for the constraint on
 * <code>nat</code> would look like this:
 * </p>
 * 
 * <pre>
 * define nat as int
 * where:
 *     load $
 *     const 0
 *     ifge goto exit
 *     fail("type constraint not satisfied")
 *  .exit:
 * </pre>
 * 
 * This wyil bytecode simply compares the special variable $ against 0. Here, $
 * represents the value held in a variable of type <code>nat</code>. If the
 * constraint fails, then the given message is printed.
 * 
 * @author David J. Pearce
 * 
 */
public class GlobalGenerator {
	private final WhileyBuilder builder;
	private final GlobalResolver resolver;	
	private final HashMap<NameID,Block> cache = new HashMap<NameID,Block>();
	
	public GlobalGenerator(WhileyBuilder builder, GlobalResolver resolver) {		
		this.builder = builder;
		this.resolver = resolver;
	}
		
	public Block generate(NameID nid) throws Exception {
		Block blk = cache.get(nid);
		if(blk == EMPTY_BLOCK) {
			return null;
		} else if(blk != null) {
			return blk;
		}
		
		// check whether the item in question is in one of the source
		// files being compiled.
		Path.ID mid = nid.module();
		WhileyFile wf = builder.getSourceFile(mid);
		if(wf != null) {
			// FIXME: the following line is necessary to terminate infinite
			// recursion. However, we really need to do better in the
			// context of recursive types with constraints.
	
			WhileyFile.Type td = wf.typeDecl(nid.name());
			if(td != null) {
				cache.put(nid, EMPTY_BLOCK);
				blk = generate(td.pattern.toSyntacticType(),td);
				if(td.constraint != null) {			
					if(blk == null) {
						blk = new Block(1);					
					}
					LocalGenerator.Environment environment = new LocalGenerator.Environment();
					int root = environment.allocate(td.resolvedType.raw());
					addDeclaredVariables(root, td.pattern,
							td.resolvedType.raw(), environment, blk);
					new LocalGenerator(this, td).generateAssertion(
							"constraint not satisfied", td.constraint, false,
							environment, blk);
				}
				cache.put(nid, blk);
				return blk;
			} else {
				Constant v = resolver.resolveAsConstant(nid);				
				if(v instanceof Constant.Set) {
					Constant.Set vs = (Constant.Set) v;
					Type.Set type = vs.type();
					blk = new Block(1);					
					blk.append(Code.Const(Code.REG_1, v));
					blk.append(Code.Assert(vs.type(), Code.REG_0, Code.REG_1,
							Code.Comparator.ELEMOF, "constraint not satisfied"));
					cache.put(nid, blk);
					return blk;
				} 
			}			
		} else {
			// now check whether it's already compiled and available on the
			// WHILEYPATH.
			WyilFile m = builder.getModule(mid);
			WyilFile.TypeDeclaration td = m.type(nid.name());
			if(td != null) {
				// should I cache this?
				return td.constraint();
			} else {
				return null;
			}
		}
		
		// FIXME: better error message?
		throw new ResolveError("name not found: " + nid);
	}
	
	public Block generate(SyntacticType t, Context context) throws Exception {
		Nominal nt = resolver.resolveAsType(t, context);
		Type raw = nt.raw();
		if (t instanceof SyntacticType.List) {
			SyntacticType.List lt = (SyntacticType.List) t;
			Block blk = generate(lt.element, context);			
			if (blk != null) {
				Block nblk = new Block(1);
				String label = Block.freshLabel();
				nblk.append(Code.ForAll((Type.EffectiveCollection) raw,
						Code.REG_0, Code.REG_1, Collections.EMPTY_LIST, label),
						t.attributes());
				nblk.append(shiftBlock(1, blk));
				// Must add NOP before loop end to ensure labels at the boundary
				// get written into Wyil files properly. See Issue #253.
				nblk.append(Code.Nop);
				nblk.append(Code.LoopEnd(label));
				blk = nblk;
			}
			return blk;
		} else if (t instanceof SyntacticType.Set) {
			SyntacticType.Set st = (SyntacticType.Set) t;
			Block blk = generate(st.element, context);
			if (blk != null) {
				Block nblk = new Block(1);
				String label = Block.freshLabel();
				nblk.append(Code.ForAll((Type.EffectiveCollection) raw,
						Code.REG_0, Code.REG_1, Collections.EMPTY_LIST, label),
						t.attributes());
				nblk.append(shiftBlock(1, blk));
				// Must add NOP before loop end to ensure labels at the boundary
				// get written into Wyil files properly. See Issue #253.
				nblk.append(Code.Nop);
				nblk.append(Code.LoopEnd(label));
				blk = nblk;
			}
			return blk;
		} else if (t instanceof SyntacticType.Map) {
			SyntacticType.Map st = (SyntacticType.Map) t;
			Block blk = null;
			// FIXME: put in constraints. REQUIRES ITERATION OVER DICTIONARIES
			Block key = generate(st.key, context);
			Block value = generate(st.value, context);
			return blk;
		} else if (t instanceof SyntacticType.Tuple) {
			// At the moment, a tuple is compiled down to a wyil record.
			SyntacticType.Tuple tt = (SyntacticType.Tuple) t;
			Type.EffectiveTuple ett = (Type.EffectiveTuple) raw;
			List<Type> ettElements = ett.elements();
			Block blk = null;
			
			int i = 0;
			for (SyntacticType e : tt.types) {
				Block p = generate(e, context);
				if (p != null) {
					if (blk == null) {
						blk = new Block(1);
					}
					blk.append(Code.TupleLoad(ett, Code.REG_1, Code.REG_0, i),
							t.attributes());
					blk.append(shiftBlock(1, p));
				}
				i = i + 1;
			}

			return blk;
		} else if (t instanceof SyntacticType.Record) {
			SyntacticType.Record tt = (SyntacticType.Record) t;
			Type.EffectiveRecord ert = (Type.EffectiveRecord) raw;
			Map<String,Type> fields = ert.fields();
			Block blk = null;			
			for (Map.Entry<String, SyntacticType> e : tt.types.entrySet()) {
				Block p = generate(e.getValue(), context);
				if (p != null) {
					if (blk == null) {
						blk = new Block(1);
					}					
					blk.append(
							Code.FieldLoad(ert, Code.REG_1, Code.REG_0,
									e.getKey()), t.attributes());
					blk.append(shiftBlock(1, p));
				}
			}
			return blk;
		} else if (t instanceof SyntacticType.Union) {
			SyntacticType.Union ut = (SyntacticType.Union) t;			
			
			boolean constraints = false;
			DecisionTree tree = new DecisionTree(raw);
			
			for (SyntacticType b : ut.bounds) {
				Type type = resolver.resolveAsType(b, context).raw();
				Block constraint = generate(b, context);
				constraints |= constraint != null;
				tree.add(type,constraint);
			}
			
			if(constraints) {
				return tree.flattern();				
			} else {
				// no constraints, must not do anything!
				return null;
			}
		} else if (t instanceof SyntacticType.Negation) {
			SyntacticType.Negation st = (SyntacticType.Negation) t;
			Block p = generate(st.element, context);
			Block blk = null;
			// TODO: need to fix not constraints
			return blk;
		} else if (t instanceof SyntacticType.Intersection) {
			SyntacticType.Intersection ut = (SyntacticType.Intersection) t;
			Block blk = null;			
			for (int i = 0; i != ut.bounds.size(); ++i) {
				SyntacticType b = ut.bounds.get(i);
				Block p = generate(b, context);
				// TODO: add intersection constraints				
			}
			return blk;
		} else if (t instanceof SyntacticType.Reference) {
			SyntacticType.Reference ut = (SyntacticType.Reference) t;			
			Block blk = generate(ut.element, context);
			// TODO: fix process constraints
			return null;
		} else if (t instanceof SyntacticType.Nominal) {
			SyntacticType.Nominal dt = (SyntacticType.Nominal) t;
			
			try {
				NameID nid = resolver.resolveAsName(dt.names,context);				
				Block other = generate(nid);
				if(other != null) {
					Block blk = new Block(1);
					blk.append(other);
					return blk;
				} else {
					return null;
				}
			} catch (ResolveError rex) {
				syntaxError(rex.getMessage(), context, t, rex);
				return null;
			}
		} else {
			// for base cases
			return null;
		}
	}
	
	/**
	 * The shiftBlock method takes a block and shifts every slot a given amount
	 * to the right. The number of inputs remains the same. This method is used 
	 * 
	 * @param amount
	 * @param blk
	 * @return
	 */
	private static Block shiftBlock(int amount, Block blk) {
		HashMap<Integer,Integer> binding = new HashMap<Integer,Integer>();
		for(int i=0;i!=blk.numSlots();++i) {
			binding.put(i,i+amount);
		}
		Block nblock = new Block(blk.numInputs());
		for(Block.Entry e : blk) {
			Code code = e.code.remap(binding);
			nblock.append(code,e.attributes());
		}
		return nblock.relabel();
	}
	
	/**
	 * The purpose of this method is to construct aliases for variables declared
	 * as part of type patterns. For example:
	 * 
	 * <pre>
	 * type tup as {int x, int y} where x < y
	 * </pre>
	 * 
	 * Here, variables <code>x</code> and <code>y</code> are declared as part of
	 * the type pattern, and we translate them into the aliases : $.x and $.y,
	 * where "$" is the root variable passed as a parameter.
	 * 
	 * @param src
	 * @param t
	 * @param environment
	 */
	private void addDeclaredVariables(int root, TypePattern pattern, Type type,
			LocalGenerator.Environment environment, Block blk) {
		
		if(pattern instanceof TypePattern.Record) {
			TypePattern.Record tp = (TypePattern.Record) pattern;
			Type.Record tt = (Type.Record) type;
			for(TypePattern element : tp.elements) {
				String fieldName = element.var;
				Type fieldType = tt.field(fieldName);
				int target = environment.allocate(fieldType);
				blk.append(Code.FieldLoad(tt, target, root, fieldName));
				addDeclaredVariables(target, element, fieldType, environment, blk);							
			}
		} else if(pattern instanceof TypePattern.Tuple){
			TypePattern.Tuple tp = (TypePattern.Tuple) pattern;
			Type.Tuple tt = (Type.Tuple) type;
			for(int i=0;i!=tp.elements.size();++i) {
				TypePattern element = tp.elements.get(i);
				Type elemType = tt.element(i);
				int target = environment.allocate(elemType);
				blk.append(Code.TupleLoad(tt, target, root, i));
				addDeclaredVariables(target, element, elemType, environment, blk);							
			}
		} else {
			// do nothing for leaf
		}
		
		if (pattern.var != null) {
			environment.put(root, pattern.var);
		}		
	}
	
	private static final Block EMPTY_BLOCK = new Block(1);
}
