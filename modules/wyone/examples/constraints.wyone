// an implementation of basic set constraints

// ====================================================================
// Boolean Expressions
// ====================================================================
term True
term False
class Bool as True | False
class BExpr as Bool | And | SubSetEq

term And{BExpr...}

reduce And{BExpr x}:
    => x

reduce And{And{BExpr... xs}, BExpr... ys}:
    => And (xs ++ ys)

reduce And{Bool b, BExpr... xs}:
    => False, if b == False
    => True, if |xs| == 0
    => And (xs)

// ====================================================================
// Set Constraints
// ====================================================================

term Set{Expr...}
term SubSetEq[Expr,Expr]

reduce SubSetEq[Set{Expr... xs}, Set{Expr... ys}]:
    => True, if no { x in xs | !(x in ys)}
    => False

reduce SubSetEq[* x, * y]:
    => True, if x == y

infer And{SubSetEq[Set{Expr... xs}, * x] s1,SubSetEq[Set{Expr... ys}, * y] s2, BExpr... rest}:
    => let zs = (xs ++ ys) 
       in And ({s1,s2,SubSetEq[Set(zs),x]} ++ rest), if x == y

infer And{SubSetEq[* x, Set{Expr... xs}] s1,SubSetEq[* y, Set{Expr... ys}] s2, BExpr... rest}:
    => let zs = { z | z in xs, true && z in ys }
       in And ({s1,s2,SubSetEq[x,Set(zs)]} ++ rest), if x == y

infer And{SubSetEq[* x, * y] s1,SubSetEq[* u, * v] s2, BExpr... rest}:
    => And ({s1,s2,SubSetEq[x,v]} ++ rest), if y == u && x != v

// ====================================================================
// Expressions
// ====================================================================

term Num(int)
term Var(string)

class Expr as Set | Num | Var