// ====================================================================
// Boolean Expressions
// ====================================================================
term True
term False
class Bool as True | False
class BExpr as Bool | And | Equals | Equals

term And{BExpr...}

rewrite And{True x}:
    => True

rewrite And{BExpr x}:
    => x

rewrite And{False, BExpr... xs}:
    => False

// ====================================================================
// Congruence
// ====================================================================
term Equals(Sum)

rewrite Equals(Num(int x)):
    => True, if x == 0
    => False

// eliminate a variable
rewrite And{Equals(Sum{|Var x, Expr... xs|}) s1, Equals(Sum{|Var y, Expr... ys|}) s2, BExpr... rest}:
    => let s3 = Equals(Sum(Neg(Sum(ys)) ++ xs))
       in And ({s1,s2,s3} ++ rest), if x == y && xs != ys // && |xs| > 0 && |ys| > 0

// ====================================================================
// Neg
// ====================================================================
term Neg(Expr)

rewrite Neg(Num(int x)):
    => Num(-x)

rewrite Neg(Neg(Expr x)):
    => x

//rewrite Neg(Sum{|Expr... xs|}):
//    => let ys = { Neg(x) | x in xs } // FIXME (should be bag)
//       in Sum(ys)

// ====================================================================
// Sum
// ====================================================================
term Sum{|Expr|}

rewrite Sum{|Num n|}:
    => n

rewrite Sum{|Num(int x), Expr... rest|}:
    => Sum(rest), if x == 0 // && |rest| > 0

rewrite Sum{|Num(int x), Num(int y), Expr... rest|}:
    => Sum (Num(x+y) ++ rest)

rewrite Sum{|Sum{|Expr... xs|}, Expr... ys|}:
    => Sum (xs ++ ys)

rewrite Sum{|Neg(Expr x), Expr y, Expr... rest|}:
    => Sum(rest), if x == y // && |rest| > 0

// ====================================================================
// Expressions
// ====================================================================

term Num(int)
term Var(string)

class Expr as Num | Var | Sum