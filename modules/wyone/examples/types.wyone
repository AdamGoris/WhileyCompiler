// defines a language of types similar to that used in Whiley (albeit
// significantly cut-down).
//
// In fact, it's the system from this paper:
// 
// * "Sound and Complete Flow Typing with Unions, Intersections and 
//    Negations", David J. Pearce, #ECSTR12-20, 2012.

// ====================================================================
// Not
// ====================================================================

term Not(Type)

reduce Not(Not(* x)):
    => x

reduce Not(And{Type... xs}):
    => let ys = { Not(x) | x in xs }
       in Union(ys)

reduce Not(Union{Type... xs}):
    => let ys = { Not(x) | x in xs }
       in And(ys)

// ====================================================================
// And
// ====================================================================

term And{Type...}

reduce And{Type x}:
    => x

reduce And{Not(Any), Type... xs}:
    => Not(Any)

reduce And{Any, Type... xs}:
    => And (xs), if |xs| > 0

reduce And{Int, Tuple y, Type... ys}:
    => Not(Any)

reduce And{And{Type... xs}, Type... ys}:
    => And (xs ++ ys)

reduce And{Not(Type x), Type y, Type... ys}:
    => Not(Any), if x == y

reduce And{Union{Type... xs}, Type... ys}:
    => let ys = { And(x ++ ys) | x in xs }
       in Union(ys)

reduce And{Int x, Not(Tuple[Type...]), Type... rest}:
    => And (x ++ rest)

reduce And{Tuple x, Not(Int), Type... rest}:
    => And (x ++ rest)

// not sure how to express this rule?
// reduce And{Tuple[Type...], Not(Tuple[Type...]), Type... rest}:
//    => ?

// ====================================================================
// Union
// ====================================================================

term Union{Type...}

reduce Union{Type x}:
    => x

reduce Union{Any, Type... xs}:
    => Any

reduce Union{Not(Any), Type... xs}:
    => Union (xs), if |xs| > 0
    => Not(Any)

reduce Union{Not(Type x), Type y, Type... ys}:
    => Any, if x == y

reduce Union{Union{Type... xs}, Type... ys}:
    => Union (xs ++ ys)

// ====================================================================
// Tuple
// ====================================================================

term Tuple[Type...]

// this rule is BROKEN!
reduce Tuple{And{Type... xs}, Type... rest}:
    => let ys = { Tuple(x ++ rest) | x in xs }
       in And(ys)

// this rule is BROKEN!
reduce Tuple{Union{Type... xs}, Type... rest}:
    => let ys = { Tuple(x ++ rest) | x in xs }
       in Union(ys)

// this rule is BROKEN!
reduce Tuple{Not(Type t), Type... rest}:
    => let pos = Tuple(Any ++ rest),
           neg = Not(Tuple(t ++ rest))
       in And {pos,neg}

// ====================================================================
// Type
// ====================================================================

term Any
term Int

class Type as Any | Int | Not | And | Tuple | Union

// ====================================================================
// Subtype
// ====================================================================

term True
term False
term Eval(Type)
term Subtype[Type,Type] // read as lhs :> rhs

reduce Subtype[Type lhs, Type rhs]:
    => Eval(And{Not(lhs),rhs})

reduce Eval(Not(Any)):
    => True

// The following is separated out as a inference.  This is sneaky, since 
// it ensures that all other rules have been applied exhaustively.
infer Eval(Type t):
    => False





